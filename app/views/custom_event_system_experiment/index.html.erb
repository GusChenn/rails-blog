<section>
  <div class="flex flex-col">
    <%= render(UserInterface::Title.new) do %>
      <%= icon('fa-solid', 'circle', class: 'text-indigo-500 text-sm mr-1') %>
      Custom Event System
    <% end %>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      I had this idea the other day of making a matrix of HTML elements that could share data among themselves through some kind of 'wire'. My idea was to click one of the elements in the matrix and have all elements tell me which element was clicked.
    <% end %>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      To accomplish that, my first thought was to use the default browser APIs (most likely something like the <code class="bg-slate-300">CustomEvent</code> interface) but then decided that I wanted to create my own event handling system because reasons (just wanted to try doing it my own way) and for that I started looking into how the default event handling system work.
    <% end %>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      Whenever a JavaScript developers want to make an element listen for an event, it usually uses the default <code class="bg-slate-300">element.addEventListener()</code> interface. This interface allows us to specify an event type (like 'click' or 'mouseover') and a callback function that will be executed when that event occurs on the element. The way I see it, there are four main things being handled by this method:
    <% end %>
    <br />

    <ol class="list-decimal list-inside">
      <li class="text-pretty text-lg leading-8 body-text font-light">
        <b class="text-pretty text-lg leading-8 body-text">Event:</b> The event subscription system must be aware of the existance of a specific event;
      </li>
      <li class="text-pretty text-lg leading-8 body-text font-light">
        <b class="text-pretty text-lg leading-8 body-text">Subscription:</b> An element opts in to listen for a specific event;
      </li>
      <li class="text-pretty text-lg leading-8 body-text font-light">
        <b class="text-pretty text-lg leading-8 body-text">Event broadcast:</b> The system detects that an event has occurred and broadcasts it to all subscribed elements;
      </li>
      <li class="text-pretty text-lg leading-8 body-text font-light">
        <strong class="text-pretty text-lg leading-7 body-text">Callback execution:</strong> The system executes the callback function from elements subscribed to the event. My system will be a little bit simpler than the browser's default event handling system in this regard: I'll add no scoping to the callback execution, meaning that if there are 5 elements subscribed to the 'click' event and any of them where clicked, all 5 elements will have their callbacks ran.
      </li>
    </ol>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      With this in mind, we are goingo to start with a simple <span class="underline decoration-2 decoration-indigo-500 text-pretty text-lg leading-8 body-text">system responsible for handling a single event that trigger a fixed callback function</span> while the <span class="underline decoration-2 decoration-pink-500 text-pretty text-lg leading-8 body-text">element simply subscribes to that event</span>.
    <% end %>
    <br />

    <div class="w-full">
      <%= render(UserInterface::ExecutableCodeBlock.new(code: <<-JAVASCRIPT))
        class EventBus {
          constructor({ eventName, callback }) {
            this.eventName = eventName
            this.callback = callback
            this.subscribedElements = []
          }

          broadcastEvent() {
            this.subscribedElements.forEach(el => {
              this.callback.call(this, el)
            })
          }

          subscribeElement(el) {
            this.subscribedElements.push(el)
          }
        }

        class EventBusElement {
          constructor({ eventBus }) {
            this.eventBus = eventBus
          }

          subscribe() {
            this.eventBus.subscribeElement(this)
          }
        }

        const eventBus = new EventBus({
          eventName: 'greet',
          callback: () => {
            console.log('Hey there!')
          }
        })

        const eventBusElement1 = new EventBusElement({ eventBus })
        const eventBusElement2 = new EventBusElement({ eventBus })

        // Subscribe the element to the event
        eventBusElement1.subscribe()
        eventBusElement2.subscribe()

        // Make the event bus trigger the callback
        eventBus.broadcastEvent()
      JAVASCRIPT
      %>
    </div>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      And it works! Now we can modify this structure so it handles multiple events with different callback functions:
    <% end %>
    <br />

    <div class="w-full">
      <%= render(UserInterface::CodeBlock.new(code: <<-JAVASCRIPT))
        class EventBus {
          // Store events in the `events` object
          constructor() {
            this.events = {}
          }

          createEvent(eventName) {
            this.events[eventName] = {
              subscribedElements: [],
            }
          }

          // Modify the methods so they work with the new `events` object
          broadcastEvent(eventName) {
            const subscribedElements = this.events[eventName]?.subscribedElements

            if(!subscribedElements) return

            subscribedElements.forEach(subscription => {
              subscription.callback.call(subscription.element)
            })
          }

          subscribeElement(element, eventName, callback) {
            this.events[eventName]?.subscribedElements.push({
              element,
              callback
            })
          }
        }

        class EventBusElement {
          constructor({ eventBus }) {
            this.eventBus = eventBus
          }

          subscribe(eventName, callback) {
            this.eventBus.subscribeElement(this, eventName, callback)
          }
        }
      JAVASCRIPT
      %>
    </div>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      Then we can make the event declaration dynamic:
    <% end %>
    <br />

    <div class="w-full">
      <%= render(UserInterface::CodeBlock.new(code: <<-JAVASCRIPT, language: 'javascript'))
        subscribeElement(element, eventName, callback) {
          // Creates the event before subscribing an element to it
          if(!this.events[eventName]) {
            this._createEvent(eventName)
          }

          this.events[eventName].subscribedElements.push({
            element,
            callback
          })
        }

        _createEvent(eventName) {
          this.events[eventName] = {
            subscribedElements: [],
          }
        }
      JAVASCRIPT
      %>
    </div>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      We can also add a new <code class="bg-slate-300">data</code> attribute to the <code class="bg-slate-300">EventBusElement</code> class. This allows us to access data from the subscribing element within the callback function:
    <% end %>
    <br />

    <div class="w-full">
      <%= render(UserInterface::ExecutableCodeBlock.new(code: <<-JAVASCRIPT))
        class EventBus {
          constructor() {
            this.events = {}
          }

          broadcastEvent(eventName) {
            const subscribedElements = this.events[eventName]?.subscribedElements

            if(!subscribedElements) return

            subscribedElements.forEach(subscription => {
              subscription.callback.call(subscription.element)
            })
          }

          subscribeElement(element, eventName, callback) {
            if(!this.events[eventName]) {
              this._createEvent(eventName)
            }

            this.events[eventName].subscribedElements.push({
              element,
              callback
            })
          }

          _createEvent(eventName) {
            this.events[eventName] = {
              subscribedElements: [],
            }
          }
        }

        class EventBusElement {
          constructor({ eventBus, data }) {
            this.eventBus = eventBus
            this.data = data
          }

          subscribe(eventName, callback) {
            this.eventBus.subscribeElement(this, eventName, callback)
          }
        }

        // Which allows us to do stuff like this:
        const eventBus = new EventBus()
        const eventBusElement = new EventBusElement({
          eventBus,
          data: {
            name: 'foo'
          }
        })

        eventBusElement.subscribe(
          'goodbye',
          function() {
            console.log(`Goodbye from ${this.data.name}`)
          }
        )

        eventBus.broadcastEvent('goodbye')
      JAVASCRIPT
      %>
    </div>
    <br />

    <%= render(UserInterface::Quote.new) do %>
      One thing i found out while working on this modification is that arrow functions don't have their own <code class="bg-slate-300">this</code> context!
    <% end %>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      And finally we can make it so elements can broadcast events to the event bus:
    <% end %>
    <br />

    <div class="w-full">
      <%= render(UserInterface::CodeBlock.new(code: <<-JAVASCRIPT))
        class EventBusElement {
          constructor({ eventBus, data }) {
            this.eventBus = eventBus
            this.data = data
          }

          subscribe(eventName, callback) {
            this.eventBus.subscribeElement(this, eventName, callback)
          }

          // Added this
          broadcastEventToEventBus(eventName) {
            this.eventBus.broadcastEvent(eventName)
          }
        }
      JAVASCRIPT
      %>
    </div>
    <br />

    <%= render(UserInterface::Paragraph.new) do %>
      And thats it! Using this system, I was able to create my original idea
    <% end %>
    <br />

    <div data-controller="custom-event" class="flex flex-col">
      <div class="flex">
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
      </div>

      <div class="flex">
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
      </div>

      <div class="flex">
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
        <div data-custom-event-target="element">el</div>
      </div>
    </div>

  </div>
</section>
